generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  role          String    @default("USER")

  accounts Account[]
  sessions Session[]

  players  Player[]
  messages Message[]
  reads MessageRead[]
  registrations TournamentRegistration[]
  checkIns TournamentCheckIn[]

}

model Player {
  id String @id @default(cuid())

  licence String  @unique
  nom     String
  prenom  String
  points  Int?
  club    String?

  ownerId String
  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  registrations TournamentRegistration[]

  createdAt DateTime @default(now())
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum Role {
  USER
  CLUB
  ADMIN
}

enum TournamentStatus {
  DRAFT
  PUBLISHED
  CLOSED
  ARCHIVED
}

enum TournamentEventStatus {
  OPEN
  FULL
  CLOSED
  CANCELLED
}

enum RegistrationStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

enum RegistrationEventStatus {
  REGISTERED
  WAITLISTED
  CHECKED_IN
  NO_SHOW
  FORFEIT
}

enum PaymentMethod {
  ONLINE
  CASH
  CARD
  TRANSFER
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum RegistrationSource {
  WEB
  ADMIN
}

enum EventGender {
  M
  F
}

model Message {
  id        String  @id @default(cuid())
  title     String
  content   String
  important Boolean @default(false)

  authorId String
  author   User   @relation(fields: [authorId], references: [id])

reads MessageRead[]

  createdAt DateTime @default(now())
}

model Tournament {
  id                  String                  @id @default(cuid())
  slug                String                  @unique
  name                String
  description         String?
  venue               String?
  registrationOpenAt  DateTime?
  registrationCloseAt DateTime?
  startDate           DateTime
  endDate             DateTime
  status              TournamentStatus        @default(DRAFT)

  events        TournamentEvent[]
  registrations TournamentRegistration[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model TournamentEvent {
  id           String         @id @default(cuid())
  tournamentId String
  tournament   Tournament     @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  code          String
  label         String
  gender        EventGender           @default(M)
  minPoints     Int?
  maxPoints     Int?
  maxPlayers    Int                   @default(32)
  startAt       DateTime
  feeOnlineCents Int
  feeOnsiteCents Int
  status        TournamentEventStatus @default(OPEN)

  registrationEvents TournamentRegistrationEvent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tournamentId, code])
  @@index([tournamentId, startAt])
}

model TournamentRegistration {
  id           String     @id @default(cuid())
  tournamentId String
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  playerId Int

  playerRefId String
  player      Player @relation(fields: [playerRefId], references: [id], onDelete: Restrict)

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  licenseNumber String?
  clubName      String?
  gender        String?
  contactEmail  String?
  contactPhone  String?
  notes         String?
  status        RegistrationStatus @default(PENDING)
  source        RegistrationSource @default(WEB)

  registrationEvents TournamentRegistrationEvent[]
  payments           TournamentPayment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tournamentId, playerId])
  @@unique([tournamentId, playerRefId])
  @@index([tournamentId, status])
}

model TournamentRegistrationEvent {
  id             String                 @id @default(cuid())
  registrationId String
  registration   TournamentRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)

  eventId String
  event   TournamentEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  seedPointsSnapshot Int?
  position           Int?
  status             RegistrationEventStatus @default(REGISTERED)
  waitlistRank       Int?

  checkIn TournamentCheckIn?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([registrationId, eventId])
  @@index([eventId, status, waitlistRank])
}

model TournamentPayment {
  id             String                 @id @default(cuid())
  registrationId String
  registration   TournamentRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)

  amountCents Int
  method      PaymentMethod
  status      PaymentStatus @default(PENDING)
  provider    String?
  providerRef String?
  paidAt      DateTime?

  createdAt DateTime @default(now())

  @@index([registrationId, status])
}

model TournamentCheckIn {
  id                  String                    @id @default(cuid())
  registrationEventId String                    @unique
  registrationEvent   TournamentRegistrationEvent @relation(fields: [registrationEventId], references: [id], onDelete: Cascade)

  checkedInAt       DateTime @default(now())
  checkedInByUserId String?
  checkedInByUser   User?    @relation(fields: [checkedInByUserId], references: [id], onDelete: SetNull)
  desk              String?
}

model MessageRead {
  id        String   @id @default(cuid())
  userId    String
  messageId String
  readAt    DateTime @default(now())

  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([userId, messageId]) // ← empêche double lecture
}
